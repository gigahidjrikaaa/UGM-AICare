# backend/app/schemas.py
from decimal import Decimal
from pydantic import BaseModel, Field, EmailStr, validator, model_validator
from typing import Any, List, Dict, Optional, Literal
from datetime import datetime, date

from app.core.llm import LLMProvider
from app.models import AppointmentStatus

#? --- Request Body Model ---

#? --- ChatEvent Model ---
class ChatEvent(BaseModel):
    type: Literal['start_module'] # Start with one type, can expand later
    module_id: str = Field(..., description="Identifier for the module to start")

class ChatRequest(BaseModel):
    google_sub: str = Field(..., description="Google 'sub' identifier for the user.")
    session_id: str = Field(..., description="Unique identifier for this specific conversation session (e.g., UUID generated by frontend).")
    provider: LLMProvider = Field(
        default="gemini",
        description="The LLM provider to use ('togetherai' or 'gemini')"
    )
    # --- Allow message/history OR event ---
    message: Optional[str] = Field(None, description="User's text message (if not an event)")
    history: Optional[List[Dict[str, str]]] = Field(None, description="Conversation history. Required if 'message' is present, optional if 'event' is present.")
    event: Optional[ChatEvent] = Field(
        default=None, 
        description="Structured event from UI (if not a message)"
    )
    # --- Optional fields ---
    model: Optional[str] = Field(
        default=None,
        description="Optional: Specify a model name override"
    )
    max_tokens: int = Field(
        default=1024,
        ge=1,
        description="Maximum number of tokens to generate"
    )
    temperature: float = Field(
        default=0.7,
        ge=0.0,
        le=2.0,
        description="Controls randomness (0.0-2.0)"
    )
    system_prompt: Optional[str] = Field(
        default="""Kamu adalah Aika, AI pendamping kesehatan mental dari UGM-AICare. Anggap dirimu sebagai teman dekat bagi mahasiswa UGM yang sedang butuh teman cerita. Gunakan bahasa Indonesia yang santai dan kasual (gaya obrolan sehari-hari), jangan terlalu formal, kaku, atau seperti robot. Buat suasana ngobrol jadi nyaman dan nggak canggung (awkward). Sebisa mungkin, sesuaikan juga gaya bahasamu dengan yang dipakai pengguna.

                Tujuan utamamu adalah menjadi pendengar yang baik, suportif, hangat, dan tidak menghakimi. Bantu pengguna mengeksplorasi perasaan mereka terkait kehidupan kuliah, stres, pertemanan, atau apapun yang ada di pikiran mereka. Validasi emosi mereka, tunjukkan kalau kamu paham dan peduli.

                PENTING: Jangan hanya bertanya "Gimana perasaanmu?" atau "Ada yang bisa dibantu?". Jadilah teman yang aktif berpikir. Ajukan pertanyaan terbuka yang menggali lebih dalam untuk membantu pengguna merefleksikan situasinya. Dorong mereka untuk memikirkan **mengapa** mereka merasa begitu, **apa** pemicunya, **pola** apa yang mungkin ada, atau **langkah kecil** apa yang mungkin bisa diambil. Contoh pertanyaan reflektif:
                - "Kira-kira, apa ya yang bikin kamu ngerasa gitu? Coba deh dipikir lagi. Jangan coba ditekan."
                - "Hmm, menarik. Menurutmu, ada hubungannya nggak sama kejadian kemarin?"
                - "Kalau misalnya dibiarin aja, kira-kira bakal gimana? Aku penasaran."
                - "Kalau kamu bisa ngasih saran ke diri sendiri, apa yang bakal kamu bilang?"
                - "Kalau kamu lihat dari sudut pandang orang lain, apa yang mereka mungkin pikirin?"
                - "Coba deh dipikirin lagi, mungkin ada cara lain buat lihat masalah ini? Another perspective gitu?"
                - "Oke, terus menurutmu, langkah paling kecil yang bisa kamu lakuin sekarang apa? Try to break it down."
                - "Aku pikir apa yang kamu lakuin udah bagus, dan kewajibanmu untuk ngelakuin tugas itu udah selesai. Memang, ada beberapa faktor yang ga bisa kita kendaliin. But that's life, right?"

                **SARAN PROAKTIF (Berikan dengan Hati-hati & Kontekstual):**
                1.  **Aktivitas Fisik:** Kalau situasinya pas dan terasa bisa membantu (misal, pengguna cerita soal stres, mood jelek, atau merasa stuck), coba **secara halus** ajak atau ingatkan tentang manfaat aktivitas fisik ringan. Contoh: *"Eh, kadang kalau lagi suntuk gitu, jalan kaki santai keliling kos/kampus bentar aja suka bikin pikiran agak plong lho. Mungkin bisa dicoba?"* atau *"Jangan lupa gerak badan juga ya, peregangan simpel aja kadang udah ngebantu banget buat ngurangin tegang."* Selalu sampaikan sebagai **opsi** atau **pengingat umum**, jangan memaksa, dan perhatikan kalau pengguna menyebutkan kondisi fisik tertentu.
                2.  **Praktik Baik Umum (Best Practices):** Berdasarkan topik obrolan, tawarkan juga **strategi coping umum** atau **tips menjaga kesejahteraan** yang relevan. Sampaikan ini sebagai **saran umum** yang *biasanya* disarankan banyak orang, bukan saran medis pribadi. Contoh:
                    * *(Jika bahas sulit tidur):* "Soal susah tidur, biasanya sih disaranin coba jaga jadwal tidur yang rutin atau hindari main HP pas udah di kasur. Mungkin bisa dicoba salah satunya?"
                    * *(Jika bahas kecemasan):* "Kalau lagi cemas banget gitu, kadang teknik tarik napas dalam-dalam atau coba fokus ke sekitar (grounding) bisa sedikit ngebantu biar lebih tenang sesaat. Pernah coba?"
                    * *(Jika bahas overthinking):* "Pas lagi overthinking, kadang nulisin apa yang dipikirin di jurnal atau coba alihin fokus ke hobi bentar bisa ngebantu mecah pikiran yang muter-muter itu."
                    * *(Jika bahas kesepian):* "Ngerasa kesepian itu berat ya.. Kadang coba reach out ke temen lama atau ikut kegiatan UKM/komunitas bisa nambah koneksi sosial lho."

                Ingat, kamu BUKAN psikolog atau dokter. Jangan pernah memberi diagnosis medis, saran pengobatan, atau terapi. Tips di atas adalah saran umum, bukan solusi pasti. Jika percakapan mengarah ke masalah serius atau pengguna tampak sangat kesulitan, **prioritaskan** untuk mengarahkan mereka secara halus agar mencari bantuan profesional (misal: konselor UGM, psikolog). Fokusmu adalah sebagai teman ngobrol yang suportif dan membantu refleksi diri. Jaga respons tetap ringkas namun bermakna.""",
        description="Optional: A system prompt to guide the AI's behavior."
    )

    @model_validator(mode='before')
    @classmethod
    def check_message_or_event(cls, values):
        has_message = bool(values.get('message'))
        has_event = bool(values.get('event'))
        has_history = values.get('history') is not None # Check if history key exists and is not None

        if has_message == has_event: # XOR logic
             raise ValueError("Either 'message'/'history' or 'event' must be provided, but not both.")

        # If message is present, history MUST also be present (and not None)
        if has_message and not has_history:
             raise ValueError("'history' is required and cannot be null when 'message' is provided.")

        # If event is present, message MUST NOT be present
        if has_event and has_message:
             raise ValueError("'message' must not be provided when 'event' is present.")

        # Allow history to be None or potentially empty list when event is present
        # No specific check needed here based on previous logic

        return values
    
    # Add validation if needed
    @validator('history', pre=True, always=True) # 'always=True' ensures it runs even if field is missing initially, 'pre=True' runs before default value assignment if any
    def check_history_format_if_present(cls, v, values):
        # This validator depends on the model_validator running first implicitly
        # We only need to validate the *content* of history if it's actually provided.
        # The model_validator already ensures history is present when message is present.

        if v is None:
             # History is allowed to be None if 'event' is driving the request
             # Or if the frontend explicitly sends null/omits it (though our frontend doesn't currently do that for events)
            return v # Pass None through

        if not isinstance(v, list):
            raise ValueError("'history' must be a list if provided.")

        # Check content only if history is a list (i.e., not None)
        # Check if history list is empty ONLY if a message is also present (logic handled by model_validator)
        # Here, just check the format if the list isn't empty
        if v: # If the list is not empty
             if not all(isinstance(item, dict) and 'role' in item and 'content' in item for item in v):
                  raise ValueError("Each item in 'history' must be a dict with 'role' and 'content'.")
             # Check if the last message is from the user, ONLY if driven by a user message (inferred from model_validator)
             # The original validator checked v[-1]['role'] != 'user'. Let's keep that logic if v is not empty.
             if values.get('message') and v[-1].get('role') != 'user':
                  raise ValueError("History must end with a 'user' message when a 'message' is provided.")

        # If it's an event request, an empty history list `[]` is acceptable if sent by frontend.
        return v

#? --- Response Body Model ---
class ChatResponse(BaseModel):
    response: str = Field(..., description="The generated response from the LLM")
    provider_used: str = Field(..., description="The LLM provider that generated the response")
    model_used: str = Field(..., description="The specific model that generated the response")
    history: List[Dict[str, str]] = Field(..., description="The updated conversation history")

class ConversationHistoryItem(BaseModel):
    role: str
    content: str
    timestamp: datetime
    session_id: str # Include session ID for grouping

    class Config:
         orm_mode = True # Or from_attributes = True

class SummarizeRequest(BaseModel):
    session_id: str 
    user_identifier: str # Google sub

#? --- Docs Schemas ---
# Documentation models
class EndpointExample(BaseModel):
    """Example request and response for an endpoint"""
    request: Dict[str, Any]
    response: Dict[str, Any]
    description: str

class EndpointDoc(BaseModel):
    """Documentation for a specific endpoint"""
    path: str
    method: str
    summary: str
    description: str
    parameters: Optional[List[Dict[str, Any]]] = None
    request_body: Optional[Dict[str, Any]] = None
    responses: Dict[str, Dict[str, Any]]
    examples: Optional[List[EndpointExample]] = None

class ModuleDoc(BaseModel):
    """Documentation for a module of related endpoints"""
    name: str
    description: str
    endpoints: List[EndpointDoc]

#? --- Email Schemas ---
# Pydantic models
class EmailRecipient(BaseModel):
    email: EmailStr
    name: Optional[str] = None

class CreateEmailTemplate(BaseModel):
    name: str
    subject: str
    body: str
    description: Optional[str] = None

class EmailRequest(BaseModel):
    template_id: int
    recipients: List[EmailRecipient]
    schedule_time: Optional[datetime] = None
    template_variables: Optional[dict] = {}

class EmailGroupCreate(BaseModel):
    name: str
    description: Optional[str] = None
    recipients: List[EmailRecipient]

class ScheduleEmailRequest(BaseModel):
    template_id: int
    group_id: int
    schedule: str  # Cron expression (e.g., "0 9 * * 1" for every Monday at 9 AM)
    template_variables: Optional[dict] = {}

#? --- Feedback Schemas ---
class FeedbackCreate(BaseModel):
    # Optional context fields from frontend
    user_identifier: Optional[str] = None # Hashed ID 
    session_id: Optional[str] = None      # Set to null/omit if general feedback
    
    # --- Fields corresponding to the specific questions ---
    # Scales (Allow null if not answered)
    ease_of_use_rating: Optional[int] = Field(None, ge=1, le=5, description="Q1: 1=Very Difficult, 5=Very Easy")
    chatbot_understanding_rating: Optional[int] = Field(None, ge=1, le=5, description="Q2: 1=Not at all, 5=Very Well")
    felt_understood_rating: Optional[int] = Field(None, ge=1, le=5, description="Q3: 1=Not at all, 5=Very Much")
    nps_rating: Optional[int] = Field(None, ge=0, le=10, description="Q5: 0-10 Likelihood to Recommend")

    # MCQ (Allow null if not answered)
    goal_achieved: Optional[Literal['Yes', 'No', 'Partially']] = Field(None, description="Q4: Did you accomplish goal?")

    # Open-Ended (Make this mandatory as requested)
    improvement_suggestion: str = Field(..., min_length=5, description="Q6: What one thing can we improve?") # Set a min_length

    # Optional category (can keep or remove)
    category: Optional[str] = None 

    # Ensure Pydantic V2 compatibility if needed
    # class Config:
    #    from_attributes = True

class FeedbackResponse(BaseModel):
    id: int
    message: str = "Feedback submitted successfully."
    timestamp: datetime

#? --- Internal API Schemas ---
class UserInternalResponse(BaseModel):
    id: int
    google_sub: str
    email: Optional[str] = None # Encrypted email, can be decrypted if needed
    wallet_address: str | None = None
    role: Optional[str] = None
    allow_email_checkins: bool = True # Whether user wants email check-ins

    class Config:
         orm_mode = True
        
#? --- Schemas for POST /internal/sync-user ---
class UserSyncPayload(BaseModel):
    google_sub: str
    email: Optional[EmailStr] = None # Validate email format from frontend

class UserSyncResponse(BaseModel):
    message: str
    user_id: int # Return the internal DB user ID
    google_sub: str
    email_stored: bool # Indicate if encrypted email is now stored

#? --- Journal Schemas ---
class JournalEntryBase(BaseModel):
    entry_date: date
    content: str

class JournalEntryCreate(JournalEntryBase):
    pass

class JournalEntryUpdate(BaseModel):
    content: str # Allow updating only content for a specific date

class JournalEntryResponse(JournalEntryBase):
    id: int
    user_id: int
    created_at: datetime
    updated_at: datetime

    class Config:
        orm_mode = True # or from_attributes = True for Pydantic v2

#? --- Link DID Schemas ---
class LinkDIDRequest(BaseModel):
    wallet_address: str

#? --- Summary Schemas ---
class ActivityData(BaseModel):
    '''Daily activity data'''
    hasJournal: bool = False
    hasConversation: bool = False

class ActivitySummaryResponse(BaseModel):
    '''Dictionary where key is "YYYY-MM-DD" string'''
    summary: Dict[str, ActivityData]
    currentStreak: int = 0 # Streak count. At least 1 day of activity is needed to count as a streak.
    longestStreak: int = 0 # Longest streak count. At least 1 day of activity is needed to count as a streak.

#? --- Pydantic Model for Earned Badge Response ---
class EarnedBadgeInfo(BaseModel):
    badge_id: int
    awarded_at: datetime
    transaction_hash: str
    contract_address: str
    # You can add more fields here later if needed, e.g., fetching metadata from DB/IPFS
    name: Optional[str] = None
    image_url: Optional[str] = None

    class Config:
        orm_mode = True # Or from_attributes = True for Pydantic v2

#? --- Pydantic Model for User Profile Response ---
class UserProfileResponse(BaseModel):
    id: int
    google_sub: str
    email: Optional[str] = None # Encrypted email, can be decrypted if needed
    wallet_address: str | None = None
    current_streak: int = 0 # Current streak count. At least 1 day of activity is needed to count as a streak.
    longest_streak: int = 0 # Longest streak count. At least 1 day of activity is needed to count as a streak.
    allow_email_checkins: bool = True # Whether user wants email check-ins

    class Config:
        orm_mode = True # or from_attributes = True for Pydantic v2
    
#? --- Pydantic Model for Check-in Settings ---
# Check-in settings model for updating user preferences
class CheckinSettingsUpdate(BaseModel):
    allow_email_checkins: bool

class CheckinSettingsResponse(BaseModel):
    allow_email_checkins: bool
    message: str = "Settings updated successfully"

#? --- Pydantic Model for Email Payload ---
# Email payload model for sending test emails
class TestEmailPayload(BaseModel):
    recipient_email: EmailStr
    subject: str = "UGM-AICare Test Email"
    message: str = "This is a test message from the UGM-AICare email utility."

#? --- Pydantic Model for Sync Achievements Response in profile.py ---
class SyncAchievementsResponse(BaseModel):
    message: str
    newly_awarded_badges: List[EarnedBadgeInfo] = [] # Return info about newly minted badges

#? --- Pydantic Model for Summary ---
class LatestSummaryResponse(BaseModel):
    summary_text: Optional[str] = None
    timestamp: Optional[datetime] = None

#? --- Pydantic Model for Greeting Hook ---
class GreetingHookRequest(BaseModel):
    detailed_summary_text: str

class GreetingHookResponse(BaseModel):
    greeting_hook: Optional[str] = None

# --- Counselor Schemas ---
class CounselorBase(BaseModel):
    name: str
    specialization: Optional[str] = None
    image_url: Optional[str] = None
    is_generally_available: bool = True
    work_hours_json: Optional[str] = None # Or parse into a structured Dict
    lisk_address: Optional[str] = None

class CounselorCreate(CounselorBase):
    pass

class Counselor(CounselorBase): # For response
    id: int

    class Config:
        orm_mode = True

# --- AppointmentType Schemas ---
class AppointmentTypeBase(BaseModel):
    name: str
    description: Optional[str] = None
    duration_minutes: int
    price_idrx_wei: Decimal # Use Decimal for precision in Pydantic, maps to Numeric

class AppointmentTypeCreate(AppointmentTypeBase):
    pass

class AppointmentType(AppointmentTypeBase): # For response
    id: int

    class Config:
        orm_mode = True

# --- Availability Slot Schema (for API response) ---
class TimeSlot(BaseModel):
    time: str # "HH:MM"
    available: bool

class AvailabilityResponse(BaseModel):
    date: date
    slots: List[TimeSlot]

# --- Appointment Schemas ---
class AppointmentCreateRequest(BaseModel): # For student initiating a booking
    counselor_id: int
    appointment_type_id: int
    appointment_date: date # e.g., "2025-05-20"
    appointment_time: str # e.g., "09:30" (will be combined with date)
    notes_for_counselor: Optional[str] = None

class AppointmentInitiateResponse(BaseModel): # Response after initiating
    appointment_id: int
    student_user_id: int
    counselor_id: int
    appointment_type_id: int
    appointment_datetime: datetime
    status: AppointmentStatus
    price_to_pay_idrx_wei: Decimal
    payment_address: str # Lisk Smart Contract address to send IDRX
    notes_for_counselor: Optional[str] = None


class AppointmentPaymentVerificationRequest(BaseModel):
    lisk_transaction_hash: str # Student provides this after sending payment

class Appointment(BaseModel): # Full appointment details for response
    id: int
    student_user_id: int
    counselor: Counselor # Nested counselor details
    appointment_type: AppointmentType # Nested type details
    appointment_datetime: datetime
    status: AppointmentStatus
    notes_for_counselor: Optional[str] = None
    counselor_notes: Optional[str] = None
    lisk_transaction_hash: Optional[str] = None
    price_paid_idrx_wei: Optional[Decimal] = None
    created_at: datetime
    updated_at: Optional[datetime] = None # onupdate might not always be there on creation

    class Config:
        orm_mode = True
        json_encoders = {
            # Handles the enum for JSON responses
            AppointmentStatus: lambda v: v.value if v else None 
        }