# backend/app/schemas/chat.py
from pydantic import BaseModel, Field, validator, model_validator, ConfigDict
from typing import Any, List, Dict, Optional, Literal
from datetime import datetime

#? --- Request Body Model ---

#? --- ChatEvent Model ---
class ChatEvent(BaseModel):
    type: Literal['start_module'] # Start with one type, can expand later
    module_id: str = Field(..., description="Identifier for the module to start")

class ChatRequest(BaseModel):
    google_sub: str = Field(..., description="Google 'sub' identifier for the user.")
    session_id: str = Field(..., description="Unique identifier for this specific conversation session (e.g., UUID generated by frontend).")
    conversation_id: str = Field(..., description="Unique identifier for the conversation thread within a session.")
    provider: Optional[Literal['gemini', 'gemma_local']] = Field(
        default="gemma_local",
        description="The LLM provider to use ('gemini' or 'gemma_local')"
    )
    # --- Allow message/history OR event ---
    message: Optional[str] = Field(None, description="User's text message (if not an event)")
    history: Optional[List[Dict[str, str]]] = Field(None, description="Conversation history. Required if 'message' is present, optional if 'event' is present.")
    event: Optional[ChatEvent] = Field(
        default=None, 
        description="Structured event from UI (if not a message)"
    )
    # --- Optional fields ---
    model: Optional[str] = Field(
        default=None,
        description="Optional: Specify a model name override"
    )
    max_tokens: int = Field(
        default=1024,
        ge=1,
        description="Maximum number of tokens to generate"
    )
    temperature: float = Field(
        default=0.7,
        ge=0.0,
        le=2.0,
        description="Controls randomness (0.0-2.0)"
    )
    system_prompt: Optional[str] = Field(
        default="""Kamu adalah Aika, AI pendamping kesehatan mental dari UGM-AICare. Anggap dirimu sebagai teman dekat bagi mahasiswa UGM yang sedang butuh teman cerita. Gunakan bahasa Indonesia yang santai dan kasual (gaya obrolan sehari-hari), jangan terlalu formal, kaku, atau seperti robot. Buat suasana ngobrol jadi nyaman dan nggak canggung (awkward). Sebisa mungkin, sesuaikan juga gaya bahasamu dengan yang dipakai pengguna.

                Tujuan utamamu adalah menjadi pendengar yang baik, suportif, hangat, dan tidak menghakimi. Bantu pengguna mengeksplorasi perasaan mereka terkait kehidupan kuliah, stres, pertemanan, atau apapun yang ada di pikiran mereka. Validasi emosi mereka, tunjukkan kalau kamu paham dan peduli.

                PENTING: Jangan hanya bertanya "Gimana perasaanmu?" atau "Ada yang bisa dibantu?". Jadilah teman yang aktif berpikir. Ajukan pertanyaan terbuka yang menggali lebih dalam untuk membantu pengguna merefleksikan situasinya. Dorong mereka untuk memikirkan **mengapa** mereka merasa begitu, **apa** pemicunya, **pola** apa yang mungkin ada, atau **langkah kecil** apa yang mungkin bisa diambil. Contoh pertanyaan reflektif:
                - "Kira-kira, apa ya yang bikin kamu ngerasa gitu? Coba deh dipikir lagi. Jangan coba ditekan."
                - "Hmm, menarik. Menurutmu, ada hubungannya nggak sama kejadian kemarin?"
                - "Kalau misalnya dibiarin aja, kira-kira bakal gimana? Aku penasaran."
                - "Kalau kamu bisa ngasih saran ke diri sendiri, apa yang bakal kamu bilang?"
                - "Kalau kamu lihat dari sudut pandang orang lain, apa yang mereka mungkin pikirin?"
                - "Coba deh dipikirin lagi, mungkin ada cara lain buat lihat masalah ini? Another perspective gitu?"
                - "Oke, terus menurutmu, langkah paling kecil yang bisa kamu lakuin sekarang apa? Try to break it down."
                - "Aku pikir apa yang kamu lakuin udah bagus, dan kewajibanmu untuk ngelakuin tugas itu udah selesai. Memang, ada beberapa faktor yang ga bisa kita kendaliin. But that's life, right?"

                **SARAN PROAKTIF (Berikan dengan Hati-hati & Kontekstual):**
                1.  **Aktivitas Fisik:** Kalau situasinya pas dan terasa bisa membantu (misal, pengguna cerita soal stres, mood jelek, atau merasa stuck), coba **secara halus** ajak atau ingatkan tentang manfaat aktivitas fisik ringan. Contoh: *"Eh, kadang kalau lagi suntuk gitu, jalan kaki santai keliling kos/kampus bentar aja suka bikin pikiran agak plong lho. Mungkin bisa dicoba?"* atau *"Jangan lupa gerak badan juga ya, peregangan simpel aja kadang udah ngebantu banget buat ngurangin tegang."* Selalu sampaikan sebagai **opsi** atau **pengingat umum**, jangan memaksa, dan perhatikan kalau pengguna menyebutkan kondisi fisik tertentu.
                2.  **Praktik Baik Umum (Best Practices):** Berdasarkan topik obrolan, tawarkan juga **strategi coping umum** atau **tips menjaga kesejahteraan** yang relevan. Sampaikan ini sebagai **saran umum** yang *biasanya* disarankan banyak orang, bukan saran medis pribadi. Contoh:
                    * *(Jika bahas sulit tidur):* "Soal susah tidur, biasanya sih disaranin coba jaga jadwal tidur yang rutin atau hindari main HP pas udah di kasur. Mungkin bisa dicoba salah satunya?"
                    * *(Jika bahas kecemasan):* "Kalau lagi cemas banget gitu, kadang teknik tarik napas dalam-dalam atau coba fokus ke sekitar (grounding) bisa sedikit ngebantu biar lebih tenang sesaat. Pernah coba?"
                    * *(Jika bahas overthinking):* "Pas lagi overthinking, kadang nulisin apa yang dipikirin di jurnal atau coba alihin fokus ke hobi bentar bisa ngebantu mecah pikiran yang muter-muter itu."
                    * *(Jika bahas kesepian):* "Ngerasa kesepian itu berat ya.. Kadang coba reach out ke temen lama atau ikut kegiatan UKM/komunitas bisa nambah koneksi sosial lho."

                Ingat, kamu BUKAN psikolog atau dokter. Jangan pernah memberi diagnosis medis, saran pengobatan, atau terapi. Tips di atas adalah saran umum, bukan solusi pasti. Jika percakapan mengarah ke masalah serius atau pengguna tampak sangat kesulitan, **prioritaskan** untuk mengarahkan mereka secara halus agar mencari bantuan profesional (misal: konselor UGM, psikolog). Fokusmu adalah sebagai teman ngobrol yang suportif dan membantu refleksi diri. Jaga respons tetap ringkas namun bermakna.""",
        description="Optional: A system prompt to guide the AI's behavior."
    )

    @model_validator(mode='before')
    @classmethod
    def check_message_or_event(cls, values):
        has_message = bool(values.get('message'))
        has_event = bool(values.get('event'))
        history_provided = 'history' in values and values.get('history') is not None

        if has_message == has_event: # XOR logic: one must be true, the other false
             raise ValueError("Either 'message' (with 'history') or 'event' must be provided, but not both or neither.")

        # If message is present, history MUST also be present (and not None)
        if has_message and not history_provided: # If message is present, history must also be present and not None
             raise ValueError("'history' is required and cannot be null when 'message' is provided.")

        return values
    
    # Add validation if needed
    @validator('history', pre=True, always=True) # 'always=True' ensures it runs even if field is missing initially, 'pre=True' runs before default value assignment if any
    def check_history_format_if_present(cls, v, values):
        # This validator depends on the model_validator running first implicitly
        # We only need to validate the *content* of history if it's actually provided.
        # The model_validator already ensures history is present when message is present.

        if v is None:
             # History is allowed to be None if 'event' is driving the request
             # Or if the frontend explicitly sends null/omits it (though our frontend doesn't currently do that for events)
            return v # Pass None through

        if not isinstance(v, list):
            raise ValueError("'history' must be a list if provided.")

        # Check content only if history is a list (i.e., not None)
        # Check if history list is empty ONLY if a message is also present (logic handled by model_validator)
        # Here, just check the format if the list isn't empty
        if v: # If the list is not empty
             if not all(isinstance(item, dict) and 'role' in item and 'content' in item for item in v):
                  raise ValueError("Each item in 'history' must be a dict with 'role' and 'content'.")

        # If it's an event request, an empty history list `[]` is acceptable if sent by frontend.
        return v

#? --- Response Body Model ---
class InterventionPlan(BaseModel):
    """SCA-generated intervention plan for user support."""
    plan_steps: List[Dict[str, Any]] = Field(..., description="Step-by-step action plan")
    resource_cards: List[Dict[str, Any]] = Field(..., description="Supportive resources")
    next_check_in: Optional[str] = Field(None, description="ISO datetime for next check-in")
    intervention_reason: Optional[str] = Field(None, description="Why this plan was triggered")


class ChatResponse(BaseModel):
    response: str = Field(..., description="The generated response from the LLM")
    provider_used: str = Field(..., description="The LLM provider that generated the response")
    model_used: str = Field(..., description="The specific model that generated the response")
    history: List[Dict[str, str]] = Field(..., description="The updated conversation history")
    module_completed_id: Optional[str] = Field(None, description="If a module was just completed, this will be its ID.")
    intervention_plan: Optional[InterventionPlan] = Field(None, description="SCA intervention plan if triggered")

    model_config = {
        "protected_namespaces": ()
    }

class ConversationHistoryItem(BaseModel):
    model_config = ConfigDict(from_attributes=True)
    
    role: str
    content: str
    timestamp: datetime
    session_id: str # Include session ID for grouping


#? --- Aika Meta-Agent Request/Response Models ---

class AikaRequest(BaseModel):
    """Request schema for Aika Meta-Agent endpoint.
    
    This schema is designed to work with the LangGraph-based orchestrator
    and matches the frontend's expected request format.
    """
    user_id: int = Field(..., description="User ID from session")
    role: Literal['user', 'counselor', 'admin'] = Field(
        default='user',
        description="User's role for routing (user=student/counselor/admin)"
    )
    message: str = Field(..., min_length=1, description="User's message")
    conversation_history: List[Dict[str, str]] = Field(
        default_factory=list,
        description="Conversation history as list of {role, content} dicts"
    )
    session_id: Optional[str] = Field(
        None,
        description="Optional session ID for continuity (auto-generated if not provided)"
    )
    
    model_config = {
        "protected_namespaces": ()
    }


class AikaResponse(BaseModel):
    """Response schema for Aika Meta-Agent endpoint.
    
    Returns Aika's response along with metadata about agent coordination.
    """
    success: bool = Field(..., description="Whether request succeeded")
    response: str = Field(..., description="Aika's response text")
    metadata: Dict[str, Any] = Field(
        ...,
        description="Metadata including agents_invoked, risk_level, processing_time_ms, etc."
    )
    error: Optional[str] = Field(None, description="Error message if success=false")
    
    model_config = {
        "protected_namespaces": ()
    }